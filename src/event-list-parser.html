<dom-module id="event-list-parser">

    <!--
    This handles the following format:

    delay+durationNAME:ARG:ARG@macro

    word word word word,word word word word,word,word word
    " " space separates each word
    "," separates words that are to be understood as on the same time, played synchronously.

    Tip, special command events are often added after a comma on the previous event, so that it is not given a separate turn.

    Each word is constructed as follows:
    [delay+][duration]NAME[:ARG][:ARG][@macro]


    [Prefix]WORD[Postfix]           prefix and postfix are optional

    Prefix = [Delay+][Duration]     both delay and duration are optional.
                                    Delay always ends with a "+".
                                    Delay is always in front of duration.

    WORD = [ARG][:ARG]*             All args that can be converted to a number, will be converted to a number.
                                    This also applies to "1/8" which might be beneficial to keep as strings..
                                    they are converted now, this might need to be altered later.

    Postfix = [@type][?prop:prop]
    Postfix = [?prop[:prop]*][@type]
                                    All types can be described in json as follows:
                                    typename : {name1 : defaultvalue1, name2 : defaultvalue2, etc}.

                                    The result is as follows: You can have
                                    a)
                                    event = "g:1",
                                    type = @piano,
                                    "piano" : {"octave": 0, "volume": 0.8}
                                    =>
                                    "g:1:0.8@piano?octave:volume"
                                    b)
                                    event = "g:1@piano?volume",
                                    type = @piano,
                                    "piano" : {"octave": 0, "volume": 0.8}
                                    =>
                                    "g:1:0@piano:volume:octave"

    Numbers.                        All units that consists only of the characters "0123456789.-/^%"
    NAME                            starts with a-zA-Z_$ and ends at the first ":@ " (Colon, at and space).
                                    Any argument that consists only of Number characters are parsed as a number.


    examples:
    0.5+2G:v.8@guitar => wait half a turn until you play a note G with a duration of 2 turns on the guitar
    $s:.5 => set the speed to hald (.5)
    $r:4:2 => repeat the four last turns two more times

    a song:
    c1 c1 c1 g a a 2g _ e1 e1

    The space separate the turns. If each turn is half a second long,
    then each turn will be delayed by half a second from the start of the
    previous turn. That will produce a rythmic sound.
    If played by a piano, this would be the start of "old macDonald had a farm".
    It could also be played by a game engine that initiates enemy spaceships
    type "c", "g", "a" etc from direction default=top, 1=left.

    TODO: Should we add "-" to describe events that are to be played sequentially, one after the other?

    The filters of events can reduce the values, but more likely they just add more values to the event.
    And then it is only a point when we compare two events that we have the same property to compare against.
    So this could be a general "event comparator", in which we just need to specify against which properties
    we are comparing.
    That would result in an event distance object. This is the distance between certain properties in two events.

    -->

    <script>

        function EventObject(str) {
            this.prefix = Object.create(null);
            this.delay = 0;
            this.duration = 1;
            this.parse(str);
        }

        EventObject.prototype = {
            /**
             * Split prefix - stemPostfix.
             * There must be a stem, but prefix is optional.
             * The prefix can only contain [0-9./-+]
             * The stem must start with a [a-zA-Z_$].
             *
             * @param word
             */
            parse: function (word) {
                var index = word.search(/[a-zA-Z_$]/);
                if (index < 0)
                    throw new Error("Syntax error: All events must include a word starting with [a-zA-Z_]: " + word);
                if (index === 0)
                    return this.parseStem(word);
                this.parsePrefix(word.substr(0, index));
                this.parseStem(word.substr(index));
            },
            parseStem: function (stem) {
                var pieces = stem.split("@");
                if (pieces.length > 2)
                    throw new Error("Syntax error: Only one postfix ('@') is allowed: " + stem);
                //do postfix first.
                var doneProps = false;
                if (pieces.length === 2) {
                    var pieces3 = pieces[1].split("?");
                    if (pieces3.length === 2) {
                        doneProps = true;
                        this.props = pieces3[1].split(":");
                        this.type = pieces3[0];
                    }
                }
                var values = pieces[0];
                var pieces2 = values.split("?");
                if (pieces2.length > 2)
                    throw new Error("Syntax error: Only one one property-separator ('?') is allowed: " + stem);
                if (pieces2.length === 2) {
                    if (doneProps)
                        throw new Error("Syntax error: Only one one property-separator ('?') is allowed: " + stem);
                    this.props = pieces2[1].split(":");
                    values = pieces2[0];
                }
                this.args = this.parseValues(values);
            },
            parseValues: function (values) {
                var ar = values.split(":");
                for (var i = 0; i < ar.length; i++)
                    ar[i] = this.parseNumber(ar[i]);
                return ar;
            },
            parsePrefix: function (prefix) {
                var dd = prefix.split("+");
                if (dd.length === 1) { //no delay, only duration
                    this.duration = this.parseNumber(dd[0]);
                } else if (dd.length > 2) {
                    throw Error("Syntax error: Illegal prefix Number format. " +
                            "Only 1 '+' is allowed in the prefix: " + prefix);
                } else if (dd[0] === "") {
                    throw Error("Syntax error: Illegal prefix Number format. " +
                            "'+' cannot start a prefix. " +
                            "'+' is put _after_ the delay value, not in front: " + prefix);
                } else {
                    this.delay = this.parseNumberStrict(dd[0]);
                    if (dd[1])        //don't bother with converting number if the duration is not specified
                        this.duration = this.parseNumberStrict(dd[1]);
                }
            },
            /**
             * @param str
             * @returns a number
             */
            parseNumberStrict: function (str) {
                if (str.search(/[^\d.-/^%]/) === -1)
                    return eval(str);
                throw new Error("Syntax error: Illegal prefix Number format. " +
                        "Delay and duration only support numbers using these symbols: [0-9./%^]. " +
                        "Your number was: " + str + " and the illegal symbol was: " + str[i] +
                        "Tips! + and - is not allowed in the delay and duration description.");
            },
            /**
             * @param str
             * @returns a number
             */
            parseNumber: function (str) {
                return str.search(/[^\d.-/^%]/) === -1 ? eval(str) : str;
            }
        };


        Polymer({
            is: 'event-list-parser',
            properties: {
                output: {
                    type: Array,
                    notify: true
                },
                input: {
                    type: String,
                    notify: true,
                    observer: "parse"
                }
            },
            ready: function(){
                console.log("unit test the parser:");
                var one = new EventObject("0.5+2G:1:1@piano?octave:duration");
                console.log(one);
            },
            parse: function () {
                if (!this.input)
                    return;
                var array = this.input.split(" ");
                for (var i = 0; i < array.length; i++)
                    array [i] = this.parseComma(array[i]);
                this.set("output", array);
            },
            parseComma: function (word) {
                var pieces = word.split(",");
                for (var i = 0; i < pieces.length; i++)
                    pieces[i] = new EventObject(pieces[i]);
                return pieces.length === 1 ? pieces[0] : pieces;
            }
        });
    </script>
</dom-module>